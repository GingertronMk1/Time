4 - Intro to the Operating System

    Introduction
        We saw last week how a computer is just a CPU, memory and IO
        CPU just executes code from memory
        Starting, when switched on, from a defined place
        The CPU will then run that code until the machine's switched off

    Low-Level
        Programs have to speak to the hardware at the lowest level
        If the hardware changes, the code has to change too
        If you want to do something different, you need to write new code
        The code is specific to the machine you're using (not just the CPU)

    Changing Programs
        The program is fixed
        If we want to do something different we need to change the program
        Raplace the ROM chip, classically
            This is a right old ball-ache

    The Operating System
        The solution is the OS
        This allows us to load and runvarious programs
            Maybe more than one at a time
        Abstracts away from the actual hardware
            The OS provides routines that we can call to do things
        It also manages resources
        Important to remember that it's just software
        No different to the stuff we write
        Often built in layers
            Higher layers will use the abstractions provided by the lower layers
        Modern OSes are made of several parts
            Kernel - the actual OS that first starts up
            Device drivers - these talk to the hardware
            System programs - programs provided by the OS to make things easier
        Here we'll be discussing the kernel and device drivers
        Facilities
            Processes
            Memory Management
            Hardware Abstraction Layer
            File System
            Networking
            Shell
            API
            Multiuser

    Application Prgramming Interface (API)
        OS needs to provide its functionality to programs
        Does this by providing a series of routines that the program calls
        This collection of routines is known as the API

    Hardware Abstraction
        OS sits between the hardware and the programmer
        We tend to write programs for an OS rather than a specific hardware setup
        This provides a consistent programming interface regardless of the underlying hardware
        Programmer programs to the OS interface (usually using a series of functions)
        Inside the OS, the function is implemented in the appropriate way for the hardware
        Program doesn't need to know what hardware it's driving
        OS API can shield programmer from the type of device
        Making it as easy to print to a printer as to print to a screen
            Same API, different device
        Abstractions exist for specific classes of devices

    Device Drivers
        Still need to change the OS if the hardware changes
        Modern OSes get around this
        The OS defines the API
        This is implemented by another bit of software called a device driver
        Each different piece of hardware has a different device driver
        OS loads in the correct one, according to the hardware present
        Program is abstracted away from having to think about the hardware by the OS
        OS abstracted from thinking about the hardware (mostly) by device drivers
        Abstractions on abstractions
        Device driver can expose APIs of its own

    Processes
        One key feature an OS allows is for a computer to run different programs
        OS starts the program going
        Program exits when finished and returns control to the OS
            Program will call the OS a lot whilst running
        OS terminology is to call the program a process
        Initially OSes ran programs in batches - batch processes
        These days an OS can run many processes at once
            Each process is given a share of CPU time
            Known as multiprogramming
        OS is responsible for loading the program into memory, allocating space for code, data, etc
        Maintains details about each process in a process table
        Processes can start other processes
            This builds up a process tree
        Typically the OS will give the user a special shell process with which they can interact
            Starting other programs etc
            Can be a command line or GUI

    Resource Management
        As soon as you've multiple programs, you need to make sure they share resources
        The program by itself can't decide which bits of memory to use
            The memory it wants might be being used by another program
            Same goes for disks, you need to coordinate how data is stored
            Otherwise one program may overwrite another
        This is the job of the OS

    Memory Management
        A program asks the OS for a block of memory to use using an API call
        The OS returns the address of some free memory
        When the program's done with it, it returns it to the OS
        Freeing the memory, again with an API
        But what happens if there's not enough memory left?
            The OS can tell the program there's no memory left
            Or it can use virtual memory
                Use the hard disk to temporarily swap another processes momory out of RAM

    Filing Systems
        The OS also manages access to storage
        It provides the idea of a file system
        Programmer asks for a particular file in a directory and can read/write the data
        The OS provides an API to access those files
            Simple operations such as open, read or write, and close
        Block Storage
            Our file systems are stored on block storage
            They store blocks of data known as sectors
                In tracks
                On cylinders
            Or they emulate that interface
            Hardware gets programmed in different ways - the OS has a device driver to talk to each
                different kind of device
        Block storage device driver provides a defined interface to access sectors on the disk
            Read or write them
        The OS then has another layer called the file system
            This translates the hierarchical system presented to the user/program
            Into requests to read/write blocks
            Via the device driver
        You can have multiple file systems on different block devices
        These can appear as different drives
        Or as one unified file system
            The OS keeps track of which file system is mounted where
            Requests for files are passed to the relevant file system driver
        UNIX takes abstraction to the limit
            EVERYTHING is considered a file and is accessed in that manner
            There's a special folder called /dev that holds files for the different devices
            Makes for a consistent API, though things can get a little weird at times

    Security
        Processes share the CPU, RAM, and really all the hardware
        There's potential for a malicious or buggy program to wreck shit
        The OS is responsible for ensuring this doesn't happen
            It gets help from the processor
        Processors provide different levels of execution
            Kernel mode
                OS runs in kernel mode, has full privilege to do anything
            User mode
                Lets the program do only what the OS allows
            Programs run in user mode
            When they call the OS, the CPU gets switched to kernel mode
        CPU also helps the OS stop processes from corrupting memory of processes
        It has a memory management unit that can be programmed by the OS
        To make it appear as if the process and the OS are the only things in memory
        When the OS switches processes, it updates the CPU such that that process's memory is
            visible
        Process Memory Switch
            Process sees logical memory addresses
            That are translated by the CPU on the fly
            Into the physical memory location in hardware
            The memory gets broken into chunks called pages

    OS Structure
        Operating Systems can end up as big programs
        Traditionally the kernel has been one big lump of code known as a monolithic kernel
            Perhaps with the device drivers loadable as modules
        Other designs are possible where the kernel is split into smaller parts that communicate by
            sending messages between one another
        There's a tradeoff between reliability and speed at play
