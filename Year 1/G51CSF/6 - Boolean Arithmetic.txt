6 - Boolean Arithmetic

    Hardware Description Languages
        Lots of HDLs around, two common ones
            Verilog
            VHDL
        We're using one that's part of NAND2TETRIS

    Designing Logic Circuits
        Helpful to build up a truth table
        Work out the equations for each output for each line based on the input
        OR each of these together for each output
        Then simplify the equations
            Use algebraic rules etc...
            Look for common sub-equations and move to a separate equation
            Aim is to use as few gates as possible
                Saves money
                Reduces propagation delay

    Numbers
        Various symbols have been used to represent numbers
            Roman numberals
            Arabic numbers
        All are an encoding for the underlying quantity
        We use the decimal system for counting
        Based around 10 because 10 fingers
        We have counting systems using other bases
            Time, for example, is base 60
        Computers just use a different encoding using two symbols
            Binary! (Base-2)

    Binary counting
        Works the same as decimal
        Except we use powers of 2 rather than 10
        So we have units: 2s, 4s, 8s, 16s, etc...

    Decimal to Binary
        Several ways to convet
        Could just test each power of 2 against the number and see if the number's bigger
        Or we can use repeated division
            Divide by 2 repeatedly and keep track of the remainders

    Binary numbers
        Often written out with leading zeros, up to a certain number of bits

    Octal and Hexadecimal
        Binary numbers get long and unwieldy
        We tend to use octal or hexadecimal to make it easier
        Both work on powers of two
            This makes converting from binary to octal/hex trivial
            Each octal digit equates to 3 consecutive bits of a binary number
            Each hex digit to 4

    Binary addition
        Build a circuit to add two binary numbers together

    Adder (not the snake)
        Half-Adder
            Each column takes in two input bits
            Produces a sum bit and a carry bit
            We can put together a truth table for this...
                A   B   S   C  
                0   0   0   0
                0   1   1   0
                1   0   1   0
                1   1   0   1
            The SUM bit XORs the two inputs, and the CARRY bit ANDs them
            Called a half-adder because it works to add two inputs, but can't do shit with a carry by itself
            We need something that takes 3 inputs and gives 2 outputs
        Full Adder
            Truth table
                Cin A   B   S   Cout
                0   0   0   0   0
                0   0   1   1   0
                0   1   0   1   0
                0   1   1   0   1
                1   0   0   1   0
                1   0   1   0   1
                1   1   0   0   1
                1   1   1   1   1
            We cn combine several of these to add two binary numbers together
            Propagation delay can mean outputs don't happen instantaneously

    Chaining full adders
        Each adder's Cout wired into Cin of the next
        nth bit of each input presented to the nth adder's inputs A and B
        First adder's carry input is usually 0
        Last adder's carry output tells us if we've overflowed

    Subtraction
        Looked at how to represent number in binary
        And how to add them using logic circuits
        What about subtraction?
        We've to look at the CPU's ALU - Arithmetic and Logic Unit
        Subtraction Logic
            We can design a logic circuit to perform the subtraction
            Half-subtractors and full subtractors
            There is another way to subtract one number from another

    Subtraction by Addition
        We can 'subtract' by adding a negative number
        eg 4096 - 2048 == 4096 + (-2048)
        The same is true in binary
        But how do we represent a negative number in binary?
        There are four approaches
            Sign and Magnitude
                If the most significant bit's 1, the number's negative
                Floating point works this way
            One's complement
                Similar to Size and Magnitude, but for the negative numbers all the bits are flipped
                    Bar the most significant, duh
            Excess-n
                Offsetting by some value, n
            Two's complement
                Similar to one's complement, but adding one to all negative numbers
                This is the one everyone uses
        HOW DO THESE HELP?
            Let's look at sign and magnitude
                We'll add -18 and 25 in 16-bit sign/mag format
                    -18 = 1000000000010010
                    25  = 0000000000011001
                We need to find the larger number and subtract the smaller number from it (based on magnitudes)
                Then adjust the signs
                Messy as fuck
            One's complement
                Negative numbers formed by inverting the bits of the equivalent positive numbers
                But has two zeros, which is a pain in the arse
                However, addition can be done using a standard full adder
                You do have to add the carry output back in at the end (sort of replicating the effect of two's complement)
            Two's complement
                Represent -x in n bits as 2^n - x
                Quick way to calculate is to invert all the bits of x and add 1
                Addition is identical to insigned numbers, but the carry bit's ignored
                The standard on all CPUs for signed numbers

    Recap
        Looked at combinatorial logic
            Output is a combination of inputs
        There's sequential logic
            Which has a time component
        And fixed functionality, which always does the same thing
