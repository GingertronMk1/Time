7 - Assembly Programming

    Introduction
        CPU gets instructions from the computer's memory
        Each instruction is encoded as a binary bit patter (opcode)
        Assembly language was developed as a human-readable form of machine code
        This is then converted to the opcodes by a tool called an Assembler

    Assembler
        Convert mnemonics to binary
            Generates the correct bit patterns for each instruction
            Can also work out address offsets
            And other conveniences
            We're using aasm as our assembler
        Assemblers tend to be simpler than compilers

    Assembly Syntax
        Tends to be more fixed than C, for example
        Although often simpler
        No functions
        Just instructions or data
        Varies from assembler to assembler, though often very similar
        Mnemonics and operands
            Instructions
            They go one tab in
        Labels
            Make it easier as a programmer to program, really
            Go on the far left
        Directives
            Useful ones
                DEFW, DEFB: define a word or byte respectievly
                We can use them to store a string
                ALIGN: align to a 4-byte boundary (sort of like softtab in vimscript)
                ORIGIN: set address code is generated from
                EQU: equate a name with something
                    Similar to #define in C
                    Jeff EQU 10538 means we can use Jeff to mean 10538 in our code
        Comments
            A ';' delimits the start and runs until end of line
            Example
                MOV R0, #65 ; moves 65 into R0
            Probably more need in Assembly than C due to Assembly's being more cryptic

    Hello World in ARM Assembler, written in Komodo
                B main

        hello   DEFB    "Hello World\n",0
        goodbye DEFB    "Goodbly Universe\n",0

                ALIGN

        main    ADR     R0, hello   ; put address of hello string in R0
                SWI     3           ; print it out
                ARD     R0, goodbye ; put address of goodbye string in R0
                SWI     3
                SWI     2           ; stop

        Branch
            Jumps to a new line
            Assembler calculates how far to jump
        ADR Instruction
            Mnemonic ARD
            Puts the address of a label in a register
            2 operands: register and address
            This isn't an actual instruction, rather a convenience of the assembler
            Replaced by an addition/subtraction instruction based on the Program Counter
        Software Interrupt
            Mnemonic SWI, SVC
            Operand: 24-bit SWI number
            Generates a software interrupt
            Causes the CPU to start executing from address location 8
            Trapped by the OS
            OS uses operand value to decide what to do
                Thing is, we don't have an OS
                Komodo traps the SWIs for us
                And provides some useful I/O routines for us
                Komodo Provided SWIs
                0   Outputs the character in the least significant byte of R0 to the terminal window
                1   Inputs the character typed into terminal window into the least significant byte
                    of R0
                2   Halts execution
                3   Prints the string pointed to by R0
                4   Prints the natural number value in R0
