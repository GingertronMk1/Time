4 - Assembly Programming

    Intro
        CPU gets instructions from the computer's memory
        Each instruction is encoded in binary
        Each CPU family has its own instruction set
            Usually incompatible with other CPU families
            They do however usually provide a similar level of features
            
    CPU Instructions
        Opcode size varies with different instruction sets
        ARM ISA has opcodes that are exactly 32 bits wide
        x86 has a variable instruction width
        A fixed instruction width makes it easier to build a CPU
        x86 has no idea how long the instruciton is until it starts decoding

    Registers
        When programming in C, we can use variables to store bits of data
        In assembler, we're at a much lower level
        If we want variables, we have to make our own in memory
        A CPU has registers
            A register can store a value that we can manipulate
            A register stores a single value within the CPU
            Thus it's faster to access than memory
            Number varies depending upon the CPU
            some have special meaning (like PC)
        ARM has 31 32bit registers (R0-R15) and a status register, CPSR

    Program Counter, PC
        Internally, the CPU has s register called the Program Counter (PC)
        This contains the address of teh current/next instruction
        PC address placed on address bus to fetch instruction
        The PC is then incremented to point at the next

    Fetch - Decode - Execute
        The CPU stires in a cycle of:
            Fetching an instruction
            Decoding the instruction
            Executing the instruction
                Which may involve accessing memory again
            Fetching the next instruction

    Reset
        CPU needs a defined startup sequence
            Otherwise we wouldn't be able to build a system
        Varies from CPU to CPU but usually involves starting to execute code at a known address
        Or looking at a specific memory loaction for the address to start at
        We build a system around the CPU so that the correct value is there
        These days there's usually some ROM mapped into the memory space at that point
            This contains the startup code (BIOS or uEFI)
        Some earlier machines had sets of switches you had to use to manually enter the bootup code

    Machine Code Instructions
        Tend to be very basic
            Load value into register
            Add value to register
            Store register to memory
            Jump to new location, etc.
        We're going to look at writing ARM Machine Code
        Acorn Risc Machine was a CPU designed by Acorn in the 1980s
        Spun out from Acorn (with Apple's help) to form Advanced Risc Machines in the early 90s
        ARM chips now power most mobile devices

    RISC
        Reduced Instruction Set Computer
        CPUs kept having 'useful' instructions added that did increasingly complex tasks
        Most programs used only small handuls of instructions
            The less common instructions can be implemented in software anyway

    Assembly Language
        Hard to remember exact bit-patterns for each opcode
        Tend to use mnemonics that people understand
            These mnemonics are called Assembly Language
            An assembler converts the assembly into the relevant opcodes

    Assembler
        Software that converts the mnemonics to binary
        Generates the correct bit patterns for each instruction
        But it can also work out things like address offsets and other conveniences
        We'll be using aasm as our assembler
        Assemblers are simpler programs than compilers

    Assembly Syntax
        Assemblers tend to have more fixed syntax
        Although often simpler
        No functions
        Just instructions or data
        Varies from assembler to assembler, but often very similar
