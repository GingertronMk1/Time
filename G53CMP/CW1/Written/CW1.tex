\title{G53MDP Mobile Device Programming}
\author{
  Jack Ellis\\
    psyje5@nottingham.ac.uk\\
    4262333
  }
\date{}
\documentclass[12pt]{article}
\pagenumbering{gobble}
\usepackage{graphicx}
\graphicspath{ {Images/} }
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\lstset{
  basicstyle=\small\ttfamily,
  language=Haskell,
  tabsize=4,
  inputpath=../
}
\lstdefinestyle{Haskell}{
  \basicstyle=\small\tt
}
\newcommand{\lstin}[3]{%
  \lstinputlisting[firstline=#1, lastline=#2]{#3}
}

\begin{document}
\maketitle
\tableofcontents
\pagebreak
\section{Task I.1: Repeat-Loop}
\subsection{Language Modification}

\subsection{Code Extensions}
\subsubsection{Token.hs}
First I modified \verb|Token.hs| to extend the \verb|Token| type with \verb|Repeat| and \verb|Until| options.

\lstin{47}{48}{Token.hs}

\subsubsection{Scanner.hs}
I then modified \verb|Scanner.hs|, adding a case to \verb|mkIdOrKwd| for the \verb|repeat| and \verb|until| keywords.

\lstin{153}{154}{Scanner.hs}

\subsubsection{AST.hs}
In \verb|AST.hs|, I added a \verb|CmdRepeat| option to the \verb|Command| data-type, containing a \verb|Command| and an \verb|Expression|, the body and condition of the loop respectively.

\lstin{118}{123}{AST.hs}

\subsubsection{Parser.y}
Updating \verb|Parser.y| was slightly more involved, adding \verb|REPEAT| and \verb|UNTIL| parts to \verb|%token|.

\lstin{72}{73}{Parser.y}

Then extending the \verb|command| portion with the AST generated in \verb|AST.hs| and wrapping everything together.

\lstin{130}{131}{Parser.y}

\subsubsection{PPAST.hs}
The final part was extending \verb|PPAST.hs| to nicely print my \verb|repeat-until| loops.
This was achieved by adding a case to the \verb|ppCommand| function.

\lstin{70}{73}{PPAST.hs}

\section{Task I.2: Conditional Expression}
\subsection{Language Modification}

\subsection{Code Modification}
\subsubsection{Token.hs}
This was a simple extension, as MiniTriangle already supports the colon operator. 
Therefore all I had to do was add a \verb|Token| case for the \verb|?| operator.

\lstin{33}{33}{Token.hs}

\subsubsection{Scanner.hs}
Here we find that the scanner already accepts the \verb|?| operator, however it does this as a normal character. 
Thus I extended the \verb|mkOpOrSpecial| function to include the \verb|"?"| case.

\lstin{132}{132}{Scanner.hs}

\subsubsection{AST.hs}
The tricky thing here was remembering that this is a conditional \textbf{expression}, not a command. 
Thus I extended the \verb|Expression| data type with the \verb|ExpCond| case.

\lstin{162}{167}{AST.hs}

\subsubsection{Parser.y}
\verb|Parser.y| was a bit more involved; first adding the \verb|'?'| case to \verb|%token|, and making it right-associative.

\lstin{74}{74}{Parser.y}
\lstin{99}{99}{Parser.y}

Then I extended the \verb|expression| function to include the ternary operator as follows.

\lstin{185}{189}{Parser.y}

\subsubsection{PPAST.hs}
Finally I extended the \verb|ppExpression| function in \verb|PPAST.hs| to support the new expression.

\lstin{96}{100}{PPAST.hs}

\section{Task I.3: Optional Else and Elsif}
\subsection{Language Modification}

\subsection{Code Modification}
\subsubsection{Token.hs}
Nothing needed to be added to \verb|Token.hs| for the optional else, however Elsif required it's own case in the \verb|Token| data-type, so I extended it as such.

\lstin{49}{49}{Token.hs}

\subsubsection{Scanner.hs}
Again, no extension was needed here for the optional else. 
I did however add the \verb|elsif| keyword to \verb|mkIdIrKwd|.

\lstin{155}{155}{Scanner.hs}

\subsubsection{AST.hs}
In AST, I modified the \verb|CmdIf| case in the \verb|Command| data-type, doing two main things. 
First was to allow for the arbitrary number of \verb|elsif| cases, which was achieved by making a list of \verb|(Expression, Command)| tuples. 
The second was to allow for the optional \verb|else| case, which was achieved by making \verb|ciElse| a \verb|Maybe Command| rather than a \verb|Command|.

\lstin{101}{105}{AST.hs}

\subsubsection{Parser.y}
Many changes were made here, including the addition of a couple of functions. 
We shall discuss these first. 
\verb|optionalElse| returns a \verb|Maybe Command|; if it gets no input corresponding to an \verb|else| case, it returns \verb|Nothing|, which can be dealt with in an interpretation step. 
If it receives an \verb|else| case, it returns \verb|Just| the command after the 'else' keyword.

\lstin{133}{135}{Parser.y}

Next is \verb|elseIfs|: this returns a list of \verb|(Expression, Command)| tuples, i.e. the format I updated the \verb|CmdIf| AST to using. 
If the function receives an empty command, it returns an empty list. 
It is then left-recursive, building up a list of \verb|(Expression, Command)| tuples starting from the left-most by recursively calling itself until it gets to an empty command.

\lstin{137}{139}{Parser.y}

Finally we shall look at the modifications to the \verb|command| section. 
This involves incorporating the changes made to the AST and the functions described above; \verb|ciCondsCmds| is fed by the first \verb|Expression| and \verb|Command| found in the \verb|if... then| of the statement, which is then prepended to the list generated by \verb|elseIfs|. 
\verb|ciElse|, now a \verb|Maybe Command|, is fed by \verb|optionalElse|.

\lstin{118}{119}{Parser.y}

\subsubsection{PPAST.hs}
Making this print prettily was relatively straightforward with the assistance of a helper function, namely one that would deal with a list of \verb|(Expression, Command)| tuples. 
This function I called \verb|ppExprsComms|. 
If ppExprsComms receives an empty list (i.e. there were no \verb|elsif| cases), it would simply print nothing, \textbf{""}. 
If it receives a populated list, it takes the head of the list, prints \textbf{"CmdElsIf"}, and the \verb|Expression| and \verb|Command| using the provided functions for those. 
It then calls itself on the tail of the list.

\lstin{75}{79}{PPAST.hs}

For the modifications on \verb|ppCommand|, I added a \verb|case of| statement with respect to the \verb|ciElse| portion of the AST. 
If this is \verb|Nothing|, the function only prints whatever \verb|if... then... elsif... then...| it receives, otherwise it prints all that as well as the final \verb|else...| case.

\lstin{54}{61}{PPAST.hs}

\section{Task I.4: More Character Literals}
\subsection{Language Modification}

\subsection{Code Modification}
\subsubsection{Token.hs}
\subsubsection{Scanner.hs}
\subsubsection{AST.hs}
\subsubsection{Parser.y}
\subsubsection{PPAST.hs}






\end{document}
