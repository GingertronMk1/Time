\title{G54RFP Coursework Part III}
\author{
  Jack Ellis \\
  psyje5@nottingham.ac.uk\\
  4262333
}
\date{}
\documentclass[12pt]{article}
\usepackage{graphicx}
\graphicspath{ {Images/} }
\usepackage{mathtools}
\usepackage {listings}
\lstset{
  breakatwhitespace=false,
  language=Haskell,
  basicstyle=\ttfamily\small,
  showstringspaces=false,
  xleftmargin=-0.1\textwidth,
  xrightmargin=-0.1\textwidth
}

\begin{document}
\maketitle
\tableofcontents

\section{Project Overview}

\textit{Breakout} is a video game published by Atari in 1976, where the player controls a paddle and must, by using this paddle to bat a ball back and forth, destroy a number of bricks arranged in rows at the top of the screen.
This project aims to create a \textit{Breakout} clone using Haskell and the Threepenny GUI library.

\section{Technical Background}

The Threepenny GUI suite is a library that allows a programmer to create reactive web applications using Haskell.
It consists of two main user-definable functions: \verb|setup| and \verb|main|.
\verb|setup| is the more interesting of the two; given a \verb|Window| it can modify the contents of the window reactively, responding to mouse and keyboard events.
\verb|main| starts what is effectively a small web server, provides it with a configuration, and calls \verb|setup| (providing it with a \verb|Window|).

\section{Implementation}

Firstly I defined 4 data types:
\begin{itemize}
  \item \verb|HitWhere|, which gives 4 options as to where the ball has hit a brick:
    \begin{itemize}
      \item \verb|InX|, meaning from either side
      \item \verb|InY|, meaning from the top or bottom
      \item \verb|InBoth|, meaning at a 45$^{\circ}$ angle
      \item \verb|Not|, meaning the ball has not hit the brick
    \end{itemize}
  \item \verb|GameState|, with 6 options as to what the current "state" of the game is:
    \begin{itemize}
      \item \verb|PreStart|, meaning that a new level has not yet begun.
      \item \verb|Going|, the normal state of the game as a level is in progress.
      \item \verb|Paused|, when the user pauses the game mid-level.
      \item \verb|LevelComplete|, where the user has completed a level by breaking all bricks on the level.
      \item \verb|Dead|, reached if the ball hits the lower extremity of the window.
    \end{itemize}
  \item \verb|Block|, a record-style type which contains information about the bricks:
    \begin{itemize}
      \item \verb|x|, the x position of the middle of the block.
      \item \verb|y|, the y position of the top of the block.
      \item \verb|isHit :: HitWhere|, whether or not (and where) the block has been hit by the ball.
      \item \verb|colour|, the colour of the block.
      \item \verb|scoreVal|, the number of points the player will gain by breaking the block.
    \end{itemize}
  \item \verb|Env|, a type encapsulating all information about the game at any given point, including:
    \begin{itemize}
      \item \verb|ballX|, the x position of the ball.
      \item \verb|ballY|, the y position of the ball.
      \item \verb|balldX|, the velocity of the ball in x towards the right side of the screen.
      \item \verb|balldY|, the velocity of the ball in y towards the bottom of the screen.
      \item \verb|paddleX|, the x position of the paddle.
      \item \verb|paddleY|, the y position of the paddle.
      \item \verb|blocks|, a list of \verb|Brick|s.
      \item \verb|gameState|, the current \verb|GameState|.
      \item \verb|level|, the current level.
      \item \verb|score|, the current score.
    \end{itemize}

\end{itemize}

I then defined various values "globally" - the width and height of the canvas, the number of blocks in x and y, the widths and heights of the blocks and paddle, and the size and initial speed of the ball (in y).
This I did because various functions later in the program (mostly to do with hit detection and drawing) will make use of these and it makes more sense to me to simply define them as values in their own right.
If I were to extend the program (for instance incorporating multiple balls or paddles) I would likely define record-style types for both of those things and include their height, width, and initial velocity within those.

\par

Using these I defined an initial environment, with the ball in the centre of the canvas "aimed" downwards at the paddle.
The blocks' initial values are generated by a list comprehension, with their colour starting out red and getting darker as their \verb|y| value increases.
The score value of a block is directly proportional to how far up it is; 100 more points per level up initially, starting at 100.
At each level the score value of the blocks is equal to the initial value defined here multiplied by the current level.

\par

To handle keyboard events I defined a function \verb|keyboardHandle|, of type \verb|Char -> Env -> Env|.
This function can be thought of as a "router" function, given that all it really does is call the correct function depending on the \verb|gameState| of the \verb|Env| passed in as an argument.
It uses the keycode of the keydown event rather than the character to allow both the arrow keys and 'a' and 'd' keys to be used for moving the paddle.

\par

\verb|updateEnv| is the most complex function defined here, updating the current \verb|Env| every "tick" of the timer (which will be discussed later).
The main part of this is updating the current position of the ball, which requires determining whether or not the ball has hit either a brick or the paddle.
If it has, the \verb|HitWhere| type is used to determine where in general the ball has hit and bounce it properly off in an elastic collision.
If the ball has hit a brick it will simply bounce off following the same laws of physics that light does: the angle of incidence (the angle the ball comes in from) equalling the angle of reflection (the angle it goes out from).
If the ball hits the bat however, its behaviour is slightly different: the ball's angle of reflection depends not on its angle of incidence but where along the paddle it strikes.
Striking the paddle in the middle will cause the ball to bounce directly upwards, and striking either side of it will cause it to "reflect" further in that direction until, if it could, striking at the extremity would cause it to "reflect" entirely side-to-side.
I felt this would make the game somewhat more interesting than a direct "reflection", given that such a setup would in fact lead to every game being the same (assuming the same starting conditions).
The list of \verb|blocks| is then filtered to remove those that have been hit, and the \verb|scoreVal| of those removed bricks is added to the player's score.

\par

Within \verb|setup| I created a \verb|timer|, which is Threepenny's method of allowing events to happen continuously without user input.
I set the interval of "ticks" (as discussed previously) to 10ms, as I felt that 100 times per second is a reasonable rate to be updating frames and the game at.
I then created an HTML5 Canvas, and a \verb|div| to wrap it in.
I then bound \verb|keyboardHandle| to any keypress event within the window, and \verb|updateEnv| to each "tick" of the timer, and - using \verb|unionWith| and \verb|accumB|, bound all of that to \verb|initEnv|.
After that I created a "status line" to be displayed within the wrapping \verb|div| above the canvas onto which the game will be drawn, which will (depending on the state of the game) show the current level and score, or prompts to go to the next level or resume/restart the game.

\par

Finally I used the \verb|on| function to, every tick of the timer, update the canvas to reflect the current \verb|Env|.

\section{Reflections}



\end{document}
